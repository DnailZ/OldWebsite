---
layout: post
title:  "动态规划中的子列与子序列"
---



##建立一个动态规划问题的框架
用数学来描述算法问题时困难的，但算法中的基本思想却可以容易地用数学来描述，这里建立一个简单动态规划的模型，方便描述动态规划问题。

动态规划问题可以写作 $$f(S)$$ 其中 $$S$$ 是一个可以暴力遍历的状态的集合，$$f$$ 时一个定义在 $${\cal {P}}(S)$$ 上的函数，满足：

$$
f(A \cup B)=g(f(A),f(B)) ,A \cap B = \emptyset
$$

为描述动态规划中的递推性质，要引入子问题的概念。将 $$S$$ 划分成以一系列子集 $$S_1,S_2,\dots$$,将 $$f(S_1),f(S_2),\dots$$ 称为子问题。

只要找到子问题之间的关系，或者将子问题转化成其他问题，就可以得到一种动态规划算法。

子列(Substring)和子序列(Subsequence)是基础动态规划经常要讨论的对象，这里罗列了其中比较基础的问题。

##子序列型问题

**1.（0-1背包）**
**2.（满足0-1背包条件的子序列个数）**
（虽然 0-1 背包不讲究元素之间的顺序，这里还是把它列做子序列问题）
首先将原问题划分成 $$n$$ 个子问题，取以 $$k$$ 为结尾元素的子序列构成子问题，发现 子问题等价于一个与原问题相似的问题。（解释一下我这句蹩脚的话，“问题”这里指求特定子序列集合元素和的最大值，“相似”指只改变数值不改变本质的问题，下同）
然后取 $$dp[\,k\,][\,W\,]$$ 为前 $$k$$ 个元素中子序列和小于 $$W​$$ 的问题，有状态转移方程：

$$
    dp[\,k\,][\,W\,]=\max\{dp[\,k-1\,][\,W\,],dp[\,k-1\,][\,W-w[\,k\,]\,]+v[\,k\,]\}
$$

最准确的写法是写成带备忘的自顶向下的形式，可以避免无关的计算，算法的时间上界为 $$O(mn)$$ 。也就是说，这个算法 $$W$$ 越大效率越低（越接近$$O(2^n)$$）,当全部是随机的实数时与暴力算法相同。
问题 **2** 的解法与 **1** 几乎完全相同，这说明动态规划中最优化问题往往和计数问题有相似的实现（完全背包的计数问题可以参考 [HDU-1284](https://vjudge.net/problem/HDU-1284)）。

**3.（最长回文子序列）**
**4.（回文子序列个数）**
**5.（最大回文子序列和）**
首先按照套路划分子问题，取以 $$k$$ 为结尾元素的子序列构成的子问题：
发现子问题之间没有直接关系，于是对子问题划分子问题，取以 $$i$$ 为首元素 $$j$$ 为尾的回文子序列构成子问题，发现问题等价与一个与原问题相似的问题（子列 $$[i:j]$$ 的回文子序列构成的问题），画出子问题的递推关系：
取阴影部分为 $$dp[\,i+1\,][\,j-1\,]$$，每一行从右到左求子问题 $$(i,j)$$ 并更新至 $$dp[\,i\,][\,j\,]​$$ 得状态转移方程：

$$
dp[\,i\,][\,j\,]=\max\{dp[\,i-1\,][\,j\,],dp[\,i\,][\,j+1\,],\\
    (dp[\,i-1\,][\,j+1\,]+2)\;\operatorname{if}\;s[\,i\,]=s[\,j\,]\}
$$

附 **4** 的状态转移方程（容斥原理既视感）：

$$
    dp[\,i\,][\,j\,]=\begin{cases}
        dp[\,i-1\,][\,j\,]+ dp[\,i\,][\,j+1\,] -dp[\,i-1\,][\,j+1\,],  & \text{if } s[\,i\,]\neq s[\,j\,] \\
        dp[\,i-1\,][\,j\,]+ dp[\,i\,][\,j+1\,]+1, & \text{if } s[\,i\,]= s[\,j\,]
        \end{cases}
$$

**6.（最长公共子序列）**
**7.（公共子序列个数）**
**8.（最大公共子序列和）**
**9.（最长递增子序列）**
**10.（递增子序列个数）**
**11.（最大递增子序列和）**
这里递增子序列可以转化成对应的公共子序列问题，但只有在特殊情况（元素不在一个序列中重复出现）下公共子序列的问题菜可以转化成递增子序列的问题。
先解决递增子序列的问题。
**9 10 11** 都可以用类似于背包的办法解决，但 **9** 有 $$O(n\lg{n})$$ 解法

//TODO

##子列型问题

**12.（最大子列和）**
**13.（m个子列构成的子序列的最大和）**[Max Sum Plus Plus (HDU-1024)](https://cn.vjudge.net/problem/HDU-1024)
取以第 $$k$$ 个元素为结尾的满足题目要求的子序列为子问题（这种取法是贯穿整个动态规划的技巧）。发现第 $$k$$ 个子问题可以转化成第 $$k-1$$ 个子问题和前 $$k-1$$ 个元素构成的 $$m-1$$ 个子列构成的子序列的最大和：

$$
\max_{i_1,j_1,\dots,i_m,k}{
    \sum_{1 \leq p \leq m}{
        a[\,i_p:j_p\,]
    }
}=
\max{\left\{
    a[\,k\,]+
    \max_{i_1,j_1,\dots,i_m,k-1}{
        \sum_{1 \leq p \leq m}{
            a[\,i_p:j_p\,]
        }
    },\\
    a[\,k\,]+
    \max_{i_1,j_1,\dots,i_{m-1},j_{m-1}}{
        \sum_{1 \leq p \leq m-1}{
            a[\,i_p:j_p\,]
        }
    }
\right\}}
$$

状态转移方程：

$$
dp[\,i\,][\,j\,]=\max\left\{dp[i][j-1]+a[j] , \max_{0<k<j}( dp[i-1][k] ) + a[j] \right\}
$$

//TODO